---
title : Compte-rendu Statistiques -- TP1
subtitle: Statistiques descriptives et visualisation d'information
author : |
  | Université de Tours
  | Moreau Clément
output :
  pdf_document :
    latex_engine : pdflatex
fontsize : 10 pt

date: "`r format(Sys.time(), '%d %B %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Rendu des questions

```{r, echo=FALSE}
# On n'oublie pas d'inclure le fichier csv que l'on étudie.
library(readr)

poke <- read_delim("poke.csv", ";", escape_double = FALSE, col_types = cols(evolving_stade = col_character(),  is_legendary = col_character(), pokedex_number = col_character()), trim_ws = TRUE)
```


## Exercice 1

On considère le data frame généré par le code suivant : 
```{r}
T <- data.frame(V1=rep(c(1, NA), 3), V2=c(seq(1,5),NA))
T
```

1. Modifier la valeur située ligne 3, colonne 1 de $T$ par la valeur 10.

> ```{r}
T[3,1] <- 10
T
```

2. Dans la colonne 2, remplacer toutes les valeurs $\geq 4$ par la valeur 20. On pourra utiliser la commande `ifelse(phi, valT, valF)` qui rend la valeur `valT` si la condition logique `phi` est vérifiée et `valF` sinon. 

> ```{r}
T$V2 <- ifelse(T$V2 >= 4, 20, T$V2)
T
```

3. On peut détecter si une valeur possède la valeur `NA` grâce à la commande `is.na()`.

> Remplacer toutes les valeurs `NA` de $T$ par la valeur 0.

> ```{r}
for(j in 1:ncol(T)) {
  T[, j] <- ifelse(is.na(T[, j]), 0, T[, j])
}
T
```
    
4. Ajouter une nouvelle colonne à $T$ qui est la moyenne des deux colonnes $V_1$ et $V_2$. 

> ```{r}
T$V3 <- (T$V1 + T$V2)/2
T
```
  
5. Ajouter au dataframe `poke` la nouvelle colonne `base_stats` qui est correspond à la somme des différentes statistiques du pokémon, c.a.d des variables `hp`, `atk`, ..., `spd`.

> ```{r}
poke$base_stats <- (poke$hp + 
                    poke$atk + 
                    poke$def + 
                    poke$sp_atk + 
                    poke$sp_def + poke$spd)
```
  
## Exercice 2

1. Dresser l'histogramme de la variable `capt_rate`. Cette variable suit-elle une loi Normale ? Expliquer votre réponse.

> ```{r}
hist(poke$capt_rate,  
     main = "Distribution de densité de la capture d'un pokémon", 
     freq = FALSE, xlab = "Capt. Rate", ylab = "Densité")
```

> _L'histogramme semble indiquer que la variable ne suit pas une loi normale. On peut corroborer cette hypothèse à l'aide un Q-Q plot._

> ```{r}
qqnorm(poke$capt_rate, main = "Diagramme Q-Q : Capture pokémon") 
qqline(poke$capt_rate, col = "red") 
```

> _L'ajustement n'est pas respecté, on peut rejeter l'hypothèse d'une loi Normale. La variable semble distribuée par pallier._

2. Dresser les graphiques des fréquences cumulées croissantes et la boite à moustaches de `capt_rate`. Que constatez-vous ? Quelles sont les similitudes entre ces deux graphiques ?  

> ```{r, out.width='70%', fig.align='center'}
plot(ecdf(poke$capt_rate), 
     verticals = TRUE, 
     do.points = FALSE, 
     xlab = "Capt. rate",
     ylab = "Freq. cum",
     main = "Fréquences cumulées : Capture")
boxplot(poke$capt_rate, 
        horizontal = TRUE,
        xlab = "Capt. rate",
        main = "Boxplot : Capture")
```  

> _On peut voir la boxplot comme une vue simplifiée des fréquences cumulées croissantes (fcc). La boxplot indique principalement les informations des quantiles $Q_1$ et $Q_3$ ainsi que la médiane. Ces informations peuvent aussi être visualisées sur le graphique des fcc mais pour tout percentile $p$._

## Exercice 3

Code pour le graphique:

```{r}
library(RColorBrewer)
barplot(table(poke$generation),
        col = brewer.pal(n = 7, name = "YlGnBu"),
        main = "Nombre de pokémons par génération")
```

## Exercice 4

1. Quel est le coefficient de corrélation entre les variables `sp_atk` et `base_stats`. Pouvez-vous expliquez pourquoi ce score est élevé ? 

> ```{r}
cor(poke$base_stats, poke$sp_atk)
```

> _Le score est élévé car la variable `sp_atk` fait partie de la combinaison linéaire qui a servi à créer `base_stats`._

2. Donner le code R permettant de générer le graphique ci-dessous. 

```{r}
library(ggplot2)
poke$is_legendary <- as.factor(poke$is_legendary)
p <- ggplot(poke, aes(x = sp_atk, y = base_stats)) + 
     geom_point(aes(color = is_legendary), alpha = 0.75) +
     geom_smooth(aes(color = is_legendary), method = "lm") +
     scale_color_manual(values=c('#999999','#E69F00')) +
     theme_classic() +
     labs(color = "is legendary",
          x = "Sp. Atk",
          y = "Total stats",
          title = "Total des statistiques d'un pokémon en fonction de sa Sp. Atk")
p
```

## Exercice 5

Supposons que l'on veuille visualiser, pour chaque type, la proportion de chaque autre type de Pokémon. Par exemple, pour le type `grass`, on souhaite connaitre la proportion de pokémons de types `grass / t` où `t` est un type quelconque.

Plus formellement, on souhaite visualiser la proportion de chaque combinaison de types $(t_1, t_2)$. 

1. Créer un dataframe doté de deux colonnes `t1` et `t2` où chaque ligne correspond à un pokémon et où `t1` correspond au type primaire du pokémon et `t2` son type secondaire. Dans le cas où `type2 = NA`, `t2` prendra la valeur de `type1`. Par exemple, si on a `type1 = grass` et `type2 = NA`, on affectera à  `t2` également la valeur `grass` ce qui correspond à dire que le pokémon est de type "plante" pur. 

> ```{r}
T <- data.frame(type1 = poke$type1,
                type2 = ifelse(is.na(poke$type2), poke$type1, poke$type2))
  ```

2. Donner le code R permettant de générer le graphique des proportions des types secondaires pour chaque type de pokémon. 

```{r, echo = FALSE}
col_type <- function(a) {
    if(a == "bug") {
        return("#CCCC33") 
    }
    if(a == "dark") {
        return("#000000") 
    }
    if(a == "dragon") {
        return("#000077") 
    }
    if(a == "electric") {
        return("#FFFF00") 
    }
    if(a == "fairy") {
        return("#E382A7") 
    }
    if(a == "fighting") {
        return("#660000") 
    }
    if(a == "fire") {
        return("#FF0000") 
    }
    if(a == "flying") {
        return("#CCCCFF") 
    }
    if(a == "ghost") {
        return("#440077") 
    }
    if(a == "grass") {
        return("#339900") 
    }
    if(a == "ground") {
        return("#FFCC00") 
    }
    if(a == "ice") {
        return("#CCFFFF") 
    }
    if(a == "normal") {
        return("#666666") 
    }
    if(a == "poison") {
        return("#9933CC") 
    }
    if(a == "psychic") {
        return("#FF0099") 
    }
    if(a == "rock") {
        return("#996633") 
    }
    if(a == "steel") {
        return("#CCCCCC") 
    }
    if(a == "water") {
        return("#0066CC") 
    }
    if (is.na(a)) {"#FFFFFF"}
    else {
        return("#FFFFFF")
    }
}
```

> ```{r}
p <- ggplot(T) +
  geom_bar(width=0.7, 
           mapping = aes(x = type1, fill = type2),
           position = "fill") +
  scale_fill_manual(values= unlist(lapply(sort(unique(T$type2)), col_type))) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(fill = "Type",
       x = "Type primaire",
       y = "Prop.",
       title = "Proportions des types et double-types des Pokémons")
p
```
  
## Exercice 6

On souhaite vérifier l'hypothèse que les pokémons roses sont davantage genrés comme femelle (`percentage_male` < 50) que les autres pokémons. 

1. Dresser l'histogramme de la variable `percentage_male` et proposer une méthode de discrétisation pour cette variable. 

> ```{r}
hist(poke$percentage_male, 
     xlab = "% Mâles",
     main = "Histogramme de la proportion de mâles chez les pokémons")
```

> _On remarque 3 étendues principales de la variables `percentage_male`:_ 

> - $\leq 30\%$ 

> - 50%

> - $\geq 80\%$

> _On peut garder l'esprit de la méthode de Jenks et attribuer les labels selon les conditions suivantes:_ 

> - _Si $\mathtt{percentage\_male} < 50 \Rightarrow \text{F}$ qui indique une prévalence des femelles._

> - _Si $\mathtt{percentage\_male} = 50 \Rightarrow \text{N}$, pour aucune prévalence (Neutre)._ 

> - _Si $\mathtt{percentage\_male} > 50 \Rightarrow \text{M}$, qui indique une prévalence des mâles._

> ```{r}
poke$percentage_male_disc <- ifelse(is.na(poke$percentage_male), NA, 
                                    ifelse(poke$percentage_male < 50, "F", 
                                    ifelse(poke$percentage_male == 50, "N", "M")))
```

2. Créer une nouvelle variable `is_pink` qui vaut 1 si le pokémon est rose et 0 sinon. 

> ```{r}
is_pink <- ifelse(poke$color == "Pink", 1, 0)
```

3. Proposer une méthode permettant vérifier l'hypothèse puis conclure. 

>  _Deux méthodologies sont valables pour corroborer notre hypothèse que les pokémons roses sont davantage genrés comme femelle:_ 

> - _À l'aide de notre discrétisation de `percentage_male` et de la variable `is_pink`, on peut effectuer un test du chi2 et regarder la $p$-valeur associée:_ 

> > ```{r}
chisq.test(table(poke$percentage_male_disc, is_pink))
```

> - _Établir le diagramme mosaïque avec les résidus de Pearson et constater s'il on observe un écart à la norme ($r > 2$) dans la case correspondant à l'événement $(\mathtt{percentage\_male\_disc} = \text{F}) \cap (\mathtt{is\_pink} = 1)$:_

> > ```{r}
mosaicplot(table(poke$percentage_male_disc, is_pink),
           shade = TRUE,
           main = "Mosaïque et résidus: La couleur rose
                   influence t-elle le genre des pokémons ?")
```

> _Dans les deux cas l'hypothèse est vérifiée. La $p$-valeur est clairement en dessous de 0.05 et l'on constate effectivement une cellule bleue foncée à l'intersection voulue._
  
## Exercice 7

1. Code pour le graphique:

> ```{r, echo = FALSE}
data_summary <- function(data, varname, groupnames){
  require(plyr)
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      sd = sd(x[[col]], na.rm=TRUE))
  }
  data_sum <- ddply(data, groupnames, .fun=summary_func,
                  varname)
  data_sum <- plyr::rename(data_sum, c("mean" = varname))
 return(data_sum)
}
```

> ```{r}
T1 <- data.frame(poke[, c("generation", "type1", "base_stats")]) ; 
names(T1) <- c("generation", "type", "base_stats") 
T2 <- subset(poke, !is.na(type2))[, c("generation", "type2", "base_stats")] ; 
names(T2) <- c("generation", "type", "base_stats") 
#
T <- data.frame(rbind(T1, T2))
summary <- data_summary(T,
                        varname = "base_stats",
                        groupnames = c("type","generation"))
#
p <- ggplot(summary, aes(x=generation, y=base_stats, color=type)) + 
  geom_point()+
  scale_color_manual(values= unlist(lapply(sort(unique(summary$type)), col_type))) +
  geom_smooth(se = FALSE) +
  theme_classic() +
  labs(title="Évolution par génération du Total stats. des pokémons 
              selon leur type",
       x = "Génération",
       y = "Total stats.",
       color = "Type")
p
```

2. Quelles analyses peut-on en tirer ? Quel est son défaut majeur ? 

> _On remarque sur ce graphique que le type de pokémons, au fil des générations, le plus favorisé quant à leur base de statistiques moyenne est le type Dragon. Le plus défavorisé est le type Insecte. Le reste des types fluctue selon les générations entre une `base_stats` $\in [380, 500]$._ 

> _Le défaut majeur de ce graphique est la lisibilité, il est très difficile de tirer des observations individuelles par type. Une possibilité pour plus de lisibilité du graphique serait de faire apparaitre uniquement certains types ou valeurs en fonction de l'objectif communicationnelle._

2. Reprendre le graphique précédent et faire figurer uniquement les courbes des types `dark` et `fairy`. On ajoutera également un ruban pour générer les écarts-types. 

> ```{r}
summary <- subset(summary, type == "fairy" | type == "dark")

p <- ggplot(summary, aes(x=generation, y=base_stats, color=type)) + 
  geom_point()+
  scale_color_manual(values = unlist(lapply(sort(unique(summary$type)), col_type))) +
  geom_ribbon(aes(ymin = base_stats-sd, ymax=base_stats+sd, fill = type),
              alpha=0.3, show.legend = FALSE)  +
  scale_fill_manual(values = unlist(lapply(sort(unique(summary$type)), col_type))) +
  geom_smooth(se = FALSE) +
  theme_classic() +
  labs(title="Évolution par génération du Total stats. des pokémons
              Dark et Fairy",
       x="Génération",
       y = "Total stats.",
       color = "Type")
p
```
> _On voit sur ce graphique que durant presque toutes les générations, les pokémons Dark étaient globalement plus puissants que les pokémons Fairy. La courbe noire est presque toujours au dessus de la courbe rose de même que le ruban noire des écarts-types.
Néanmoins, on observe un revirement pour la dernière génération où le point et la courbe roses sont au dessus des deux indicateurs noirs. De plus, le ruban noire est en dessous du rose ce qui indique que les pokémons Dark sont globalement plus faibles que les Fairy pour la génération 7._

## Exercice 8

```{r, results='hide'}
library("mixtools")
EM_poke <- normalmixEM(poke$base_stats, mu = c(320, 480), sigma=c(50,100), k=2)

plot(EM_poke, which=2,      
     xlab2 = "Total stats.",
     main2 = "Distribution de densité de la sommes des statistiques\n des pokémons",
     lwd2=0.8)
lines(density(EM_poke$x), lty=2, lwd=0.8)
```

1. Quel phénomène selon vous peut expliquer l'apparition de mélanges gaussiens ? 

> _Un mélange gaussien au sein d'une variable est caractérisé par des sous groupes d'individus $G_1, G_2,...G_p$ de proportion $\pi_1, ..., \pi_p$ qui suivent chacun une loi normale de moyenne $\mu_{k}$ et de matrice de variance-covariance $\Sigma_{k}$. On note $\theta = \{\mu_{i=1,...,p}, \Sigma_{i=1,...,p}\}$ la mixture à $g$ composantes. Ainsi, on a:_

$$P(\theta)=\sum_{i=1}^p \pi_i  \mathcal{N}(\mu_i, \Sigma_i)$$

2. Déterminer une méthodologie d'analyse, que vous détaillerez, permettant d'expliquer la présence des deux gaussiennes sur le graphique précédent. 

> _Compte tenu de la mixture observée, on peut chercher le groupe d'individus caractérisé par la gaussienne rouge et le groupe d'individus caractérisé par la gaussienne verte._

> _On note $\mu_1 = 320,\sigma_1 = 50$ respectivement la moyenne et l'écart-type de la gaussienne rouge (resp. $\mu_2 = 480 ,\sigma_2 = 100$). Ainsi, pour chaque individu $i$, si $\mathtt{base\_stats}_i \in [\mu_1 - 2\sigma_1, \mu_1 + 2\sigma_1]$, on admettra que $i\in G_1$, (resp. pour la gaussienne verte). On notera que $i$ peut appartenir à la fois à $G_1$ et $G_2$._

> _Enfin, on analysera chacun des groupes $G_1$ et $G_2$ afin de déterminer la prévalence d'une caractérisque au sein de chacun des groupes._

> ```{r}
mu_1 <- 320
sigma_1 <- 50
G_1 <- subset(poke, base_stats >= (mu_1 - 2 * sigma_1) 
              & base_stats <= (mu_1 + 2 * sigma_1))

mu_2 <- 480
sigma_2 <- 100
G_2 <- subset(poke, base_stats >= (mu_2 - 2 * sigma_2) 
              & base_stats <= (mu_2 + 2 * sigma_2))
```

3. Conclure votre analyse et expliquer à quoi correspond, en terme d'individus, chacune de ces gaussiennes. 

> _On peut s'intéresser à la variable `evolving_stade` de chacun de groupes._

> ```{r, out.width='50%', fig.show='hold'}
library(viridis)
barplot(table(G_1$evolving_stade),
        col = inferno(4),
        ylab = "Total stats.",
        xlab = "Evo. stade",
        main = "Nombre pokémon par stade évolution (G1)")
        
barplot(table(G_2$evolving_stade),
        col = inferno(4),
        ylab = "Total stats.",
        xlab = "Evo. stade",
        main = "Nombre pokémon par stade évolution (G2)")
```

> _On voit ici que $G_2$ comporte beaucoup plus de pokémons d'évolution terminale (stade 3), qui sont les plus forts et donc avec une `base_stats` élevée, tandis que $G_1$ concentre lui les pokémons des stades inférieurs (stade 1 principalement)._  

## Exerice 9 

```{r, results='hide', fig.keep='all'}
library("corrplot")
source("http://www.sthda.com/upload/rquery_cormat.r")

num_var <- poke[,25:ncol(poke)-1]
col<- colorRampPalette(c("red", "white", "blue"))(20)
rquery.cormat(num_var, graphType="heatmap", col = col)
```

Donner une analyse du dernier diagramme (carte de chaleur et dendrogramme). 

_Une case bleue signifie que l'efficacité du type $T_1$ et du type $T_2$ sont positivement corrélée. Autrement dit, on a de bonne chance qui si la variable `against_T1` soit haute pour un pokémon, la variable `against_T2` le soit aussi (resp. basse). À l'inverse, une case rouge indique que si `against_T1` est importante, alors `against_T2` sera probablement faible. 
Le dendrogramme en haut et sur le côté groupe les variables en fonction de leur corrélation. Plus celle-ci est forte, plus les variables sont agrégées bas dans l'arbre du dendrogramme (i.e. considérées comme similaires)._

